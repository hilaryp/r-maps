# telsur-example.R by Hilary Prichard, 13 Jan. 2014
# ggplot updates by Aaron Ecay
# This file walks you through the code to create a basic ANAE-style map.

# If you haven't already installed the needed packages, uncomment this line
# and do so now:
# install.packages(c("maps", "ggplot2", "ggmap"))

# First load the packages you will need:
library(maps)
library(ggplot2)
library(ggmap)

# Read the sample telsur data csv into an R dataframe
telsur <- read.csv("telsur-example.csv")

# Have a look at the data, does everything look fine?
summary(telsur)

# Add a new column, coding the o_oh variable
# using 'with' here allows you to reference the column name directly
telsur$o_oh_level<- with(telsur,
                         ifelse(o_oh == 0, "merged",
                                ifelse(o_oh > 0 & o_oh <= 19, "close",
                                       ifelse(o_oh > 19, "distinct", NA))))

# Now if you look at the first few rows of telsur, you'll see the new column
head(telsur)

# The first layer of data we want to create for our map is the state
# boundaries.  We assign the map from the "maps" package to a variable, then
# use ggplot2's "fortify" function to turn this into a format that ggplot
# understands.

map.raw <- map("state",      # Which map to plot
               plot = FALSE, # By default "map" draws the map on a plot; we
                             # only want to extract the data; ggplot will
                             # handle the plotting later
               fill = TRUE)  # We want the states to be solid on the inside,
                             # not hollow.

map.data <- fortify(map.raw) # Now the data are in a format ggplot
                             # understands; the details of this format are not
                             # so important to us.

# Let's make a plot!  Ggplot lets us build up the plot incrementally,
# which is nice if you are not sure what you want it to look like exactly.

# The root of a ggplot is the ggplot object.  This contains an aes(thetic)
# mapping columns to attributes of the plot, and a dataframe from which to
# take the columns.  We assign this plot to a variable so we can update it
# later.
states.plot <- ggplot(aes(x = long, y = lat), data = map.data) +
    # Now we add one or more geoms to the data.  If we want fixed, rather than
    # data-dependent values, we specify them *outside* of aes.  The group
    # aesthetic tells ggplot when to "lift the pen" as it draws the state
    # borders; try leaving it out and see what happens.  The group info is
    # automatically generated by the fortify function.
    geom_polygon(aes(group = group), fill = "cornsilk", color = "black")

# Now we need to print the plot in order to see it
print(states.plot)

# Let's add our linguistic data to the plot, as points
ling.plot <- states.plot +
    geom_point(aes(x = Longitude, y = Latitude, color = o_oh_level),
               data = telsur)
# Each geom can have its own data source and aes, as this one does.  In
# addition to controling the color of points, you can also control the shape,
# which is sometimes useful.  Be wary of packing too many features into a
# single plot, though.  Perception research shows that (in contexts like this
# one) humans are capable of attending to maximally 2-3 different shapes and
# 5-6 different color categories.

print(ling.plot)

# Now we have a plot that is basically right, but it needs to be cleaned up.
# Let's get rid of the grid lines and add some nice labels

nice.plot <- ling.plot +
    theme_nothing(legend = TRUE) +                   # Remove grids etc.
    ggtitle("Example map") +
    scale_color_discrete("Perception of /o/~/oh/")

print(nice.plot)

# This looks very good, except the map is stretched to fit the graphing
# window.  We need to tell ggplot that this is a map, and so it should not do
# any stretching.

final.plot <- nice.plot +
    coord_map(projection = "mercator")

# Notice we pass a projection argument, which controls how the 3D globe is
# flattened.  There are dozens of possible choices; the default (Mercator)
# usually looks like what people are accustomed to, but it has its drawbacks.
# You can get a list of all available projections by typing "?mapproject" into
# R; pick one which suits your particular map.

print(final.plot)

# This looks pretty good! Ultimately you'll want to save your maps;
# I recommend saving as a pdf, using cairo_pdf(). For journal submission,
# you may be asked for higher-quality images, in which case use svg().
# Here's the full code for saving this map as a pdf:

cairo_pdf("telsur-example.pdf", width = 6.5, height = 4,
          pointsize = 12, family = "Times")
print(final.plot)
dev.off()

# Note that within cairo_pdf() you can specify map size, font size, and
# font family. Always follow your map code with dev.off() - this tells R you're
# done adding things to the plot, it's time to create the file.

# Congrats, now you have your first map!
# (The pdf should be in the same folder as this code.)

# Zooming in

# Sometimes, you may wish to zoom in to show just a section of a map.  Here is
# an easy way to do this.

# First, show the map you are interested in
print(final.map)

# Now, call the gglocator function.  Your cursor will turn into cross-hairs.
# Click on two corners of the rectangle you would like to zoom in on (e.g. top
# right and bottom left)
gglocator(2)

# You should see two lat, long pairs returned.  I clicked on West Virginia,
# and then just north of Maine, and got:
#        long      lat
# 1 -81.95211 38.01883
# 2 -67.51970 48.30206

# Now, we need to pass these values as limits to coord_map
print(final.plot + coord_map(xlim = c(-81.95, -67.51), ylim = c(38.01, 48.30)))
